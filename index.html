<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Signal Encoding Visualization (Strong Grid)</title>
    <style>
        body { font-family: 'Sarabun', sans-serif; background-color: #f4f4f9; padding: 20px; max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: #333; }
        .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; text-align: center; }
        input { padding: 10px; font-size: 18px; width: 300px; letter-spacing: 3px; text-align: center; border: 1px solid #ccc; border-radius: 4px; }
        .chart-container { background: white; padding: 10px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow-x: auto; }
        canvas { display: block; margin: 0 auto; }
        .chart-title { font-weight: bold; margin-bottom: 10px; color: #0056b3; border-bottom: 2px solid #eee; padding-bottom: 5px; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <h1>จำลองสัญญาณ Digital Encoding</h1>
    
    <div class="controls">
        <label>ป้อนข้อมูลบิต (0 หรือ 1): </label><br>
        <input type="text" id="bitInput" value="1011001110101" oninput="drawAll()">
    </div>

    <div id="charts"></div>

<script>
    const CHART_HEIGHT = 100;
    const BIT_WIDTH = 50;
    const PADDING_LEFT = 60;
    const PADDING_RIGHT = 20;

    function drawAll() {
        const input = document.getElementById('bitInput').value;
        const bits = input.split('').filter(c => c === '0' || c === '1').map(Number);
        const container = document.getElementById('charts');
        container.innerHTML = '';

        if (bits.length === 0) return;

        const methods = [
            { name: "1. NRZ-L (0=High, 1=Low)", func: getNRZL },
            { name: "2. NRZI (Transition on 1)", func: getNRZI },
            { name: "3. Bipolar-AMI (0=Zero, 1=Alt +/-)", func: getAMI },
            { name: "4. Pseudoternary (1=Zero, 0=Alt +/-)", func: getPseudo },
            { name: "5. Manchester (0=H->L, 1=L->H)", func: getManchester },
            { name: "6. Differential Manchester (Trans at start on 0)", func: getDiffManchester },
            { name: "7. RZ (Return to Zero)", func: getRZ }
        ];

        methods.forEach(m => {
            createChart(m.name, bits, m.func);
        });
    }

    function createChart(title, bits, signalFunc) {
        const div = document.createElement('div');
        div.className = 'chart-container';
        
        const titleElem = document.createElement('div');
        titleElem.className = 'chart-title';
        titleElem.textContent = title;
        div.appendChild(titleElem);

        const canvas = document.createElement('canvas');
        canvas.height = CHART_HEIGHT;
        canvas.width = PADDING_LEFT + (bits.length * BIT_WIDTH) + PADDING_RIGHT;
        div.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        drawGrid(ctx, bits);
        drawSignal(ctx, bits, signalFunc);
        
        document.getElementById('charts').appendChild(div);
    }

    function drawGrid(ctx, bits) {
        // --- แก้ไขจุดที่ 1: เปลี่ยนสีเส้นให้เข้มขึ้น (สีเทาเข้ม) ---
        ctx.strokeStyle = '#777777'; 
        // --- แก้ไขจุดที่ 2: เพิ่มความหนาของเส้น ---
        ctx.lineWidth = 2;
        
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';

        // Draw horizontal levels
        const mid = CHART_HEIGHT / 2;
        const top = mid - 30;
        const bot = mid + 30;

        // Labels
        ctx.fillStyle = '#666';
        ctx.fillText('+V', 25, top + 5);
        ctx.fillText('0', 25, mid + 5);
        ctx.fillText('-V', 25, bot + 5);

        // Vertical lines & Bit numbers
        for (let i = 0; i <= bits.length; i++) {
            const x = PADDING_LEFT + (i * BIT_WIDTH);
            
            // Grid line
            ctx.beginPath();
            ctx.moveTo(x, 10);
            ctx.lineTo(x, CHART_HEIGHT - 10);
            // --- แก้ไขจุดที่ 3: ปรับระยะห่างของเส้นปะให้ชัดขึ้น (ขีด 5px, เว้น 3px) ---
            ctx.setLineDash([5, 3]);
            ctx.stroke();

            // Bit Label
            if (i < bits.length) {
                ctx.fillStyle = '#000';
                // ปรับตำแหน่งตัวเลขบิตให้อยู่กึ่งกลางช่องมากขึ้นเล็กน้อย
                ctx.fillText(bits[i], x + (BIT_WIDTH / 2), 20);
            }
        }
        // Reset line dash for the signal text
        ctx.setLineDash([]);
    }

    function drawSignal(ctx, bits, logicFunc) {
        const points = logicFunc(bits);
        
        ctx.strokeStyle = '#e63946';
        ctx.lineWidth = 3;
        ctx.beginPath();

        const mid = CHART_HEIGHT / 2;
        const scale = 30; // Scale factor for +/- 1

        points.forEach((pt, i) => {
            const x = PADDING_LEFT + (pt.t * BIT_WIDTH);
            const y = mid - (pt.v * scale);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        // Reset line dash to ensure signal is solid
        ctx.setLineDash([]);
        ctx.stroke();
    }

    // --- Logic Functions (เหมือนเดิม) ---
    function getNRZL(bits) {
        let pts = [];
        bits.forEach((b, i) => {
            let val = (b === 0) ? 1 : -1;
            pts.push({t: i, v: val});
            pts.push({t: i+1, v: val});
        });
        return pts;
    }
    function getNRZI(bits) {
        let pts = [];
        let curr = -1; 
        bits.forEach((b, i) => {
            if (b === 1) curr *= -1;
            pts.push({t: i, v: curr});
            pts.push({t: i+1, v: curr});
        });
        return pts;
    }
    function getAMI(bits) {
        let pts = [];
        let lastOne = -1;
        bits.forEach((b, i) => {
            let val = 0;
            if (b === 1) {
                lastOne *= -1;
                val = lastOne;
            }
            pts.push({t: i, v: val});
            pts.push({t: i+1, v: val});
        });
        return pts;
    }
    function getPseudo(bits) {
        let pts = [];
        let lastZero = -1;
        bits.forEach((b, i) => {
            let val = 0;
            if (b === 0) {
                lastZero *= -1;
                val = lastZero;
            }
            pts.push({t: i, v: val});
            pts.push({t: i+1, v: val});
        });
        return pts;
    }
    function getManchester(bits) {
        let pts = [];
        bits.forEach((b, i) => {
            let start = (b === 0) ? 1 : -1;
            let end = (b === 0) ? -1 : 1;
            pts.push({t: i, v: start});
            pts.push({t: i+0.5, v: start});
            pts.push({t: i+0.5, v: end});
            pts.push({t: i+1, v: end});
        });
        return pts;
    }
    function getDiffManchester(bits) {
        let pts = [];
        let curr = -1; 
        bits.forEach((b, i) => {
            if (b === 0) curr *= -1; 
            pts.push({t: i, v: curr});
            pts.push({t: i+0.5, v: curr});
            curr *= -1; 
            pts.push({t: i+0.5, v: curr});
            pts.push({t: i+1, v: curr});
        });
        return pts;
    }
    function getRZ(bits) {
        let pts = [];
        bits.forEach((b, i) => {
            let val = (b === 1) ? 1 : -1;
            pts.push({t: i, v: val});
            pts.push({t: i+0.5, v: val});
            pts.push({t: i+0.5, v: 0});
            pts.push({t: i+1, v: 0});
        });
        return pts;
    }

    drawAll();
</script>

</body>
</html>